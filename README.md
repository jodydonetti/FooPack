# FooPack


## 🤔 What's this?

This is just a POC (Proof Of Concept) repo, created while discussing [this issue](https://github.com/Cysharp/MemoryPack/issues/96) where I highlighted that the current approach of MemoryPack (amazing library btw, check it out!) violates the .NET versions compatibility rules.

This repo contains a concrete example of the solution I meant when talking with @neuecc, MemoryPack creator.

## 📚 A Recap

Without having to copy paste everything here, I think [this comment](https://github.com/Cysharp/MemoryPack/issues/96#issuecomment-1357330456) of mine summarizes the problem in a very clear way.

In particular this is the issue:

> To quickly recap the issue I think we have here:
> 1) MemoryPack targets both .NET Standard 2.1 and .NET 7, so it is saying it supports ANY of them, not BOTH of them TOGETHER
> 2) any .NET Standard 2.1 package should work with any concrete .NET version that is compatible with such 2.1 standard version (which includes .NET 3.0, 3.1, 5.0, 6.0 and 7.0)
> 3) currently this is not the case, and the dependency is broken, since any package working with MemoryPack MUST multi-target to .NET 7 explicitely to be able to function, which is non-standard behaviour

Basically this:

`.NET 7 app` --> `.NET Standard 2.1 lib` --> `.NET Standard 2.1 lib`

should work but currently, with MemoryPack it does not:

`.NET 7 app` --> `.NET Standard 2.1 lib` --> `MemoryPack (.NET Standard 2.1 lib)`


## 🎉 A Solution

The solution I proposed was something like this:

> would it be possible for MemoryPack, when running on .NET 7, to be able to work with code generated by the source generator in both a .NET Standard 2.1 AND .NET 7 versions? Meaning that to get the full blown perf you must have all the formatters generated on .NET 7, ok, but it would still be possible for it to work with .NET Standard 2.1 formatters, just in a less performant way?

Later on, I put down more details in [this comment](https://github.com/Cysharp/MemoryPack/issues/96#issuecomment-1363435453):

> The generator can then generate the needed concrete formatter classes (like MyTypeFormatter for the type MyType) by always implementing the first interface (which would make it usable by any NET compatible with NS 2.1), and the second interface inside an #if NET7_0_OR_GREATER block, with the even more optimized version targeting NET 7.

And so on, you can read the full details there.

Now, probably because I haven't been able to explain myself clearly, MemoryPack's author responded by saying that my solution was not doable.

Also, since I haven't yet played with source generators (but only read something here and there), maybe I was missing something or maybe I just explained myself badl.

So anyway I created this to actually try my approach and showcase what I meant.


## ⚠ Just a POC!

Again, this is just a Proof Of Concept for the approach.

This does NOT represent real code, is NOT a serializer, is super SIMPLE and INCOMPLETE, and does NOT do anything useful.

To better understand: there's just a `Serialize()` method (no `Deserialize()`), and that method just returns a string like `"running simple code"` or something like that.

We are only interested in understanding if it is possible to have the approach I proposed, so it's not a full working project.


## 📁 Solution Structure

There are 2 "engine" projects:

- `FooSerializer.Core`: contains the core interfaces and classes, like `IFooSerializer` (core serialization methods) and `IFooFormatterNet7` (that derives from `IFooSerializer` and adds optimized .NET 7 methods), on top of the global `Foo` static class that resembles 


## 🏁 Results
