# FooPack


## 🤔 What's this?

This is just a POC (Proof Of Concept) repo, created while discussing [this issue](https://github.com/Cysharp/MemoryPack/issues/96) where I highlighted that the current approach of MemoryPack (amazing library btw, check it out!) violates the .NET versions compatibility rules.

This repo contains a concrete example of the solution I meant when talking with @neuecc, MemoryPack creator.

## 📚 A Recap

Without having to copy paste everything here, I think [this comment](https://github.com/Cysharp/MemoryPack/issues/96#issuecomment-1357330456) of mine summarizes the problem in a very clear way.

In particular this is the issue:

> To quickly recap the issue I think we have here:
> 1) MemoryPack targets both .NET Standard 2.1 and .NET 7, so it is saying it supports ANY of them, not BOTH of them TOGETHER
> 2) any .NET Standard 2.1 package should work with any concrete .NET version that is compatible with such 2.1 standard version (which includes .NET 3.0, 3.1, 5.0, 6.0 and 7.0)
> 3) currently this is not the case, and the dependency is broken, since any package working with MemoryPack MUST multi-target to .NET 7 explicitely to be able to function, which is non-standard behaviour

Basically this in general must work:

✅ `.NET 7 app` --> ✅ `.NET Standard 2.1 lib` --> ✅ `.NET Standard 2.1 lib`

But currently, with MemoryPack, if in the middle lib you generate a formatter, it does not:

⛔ `.NET 7 app` --> ✅ `.NET Standard 2.1 lib` --> ✅ `MemoryPack (.NET Standard 2.1 lib)`

because the code generated in a .NET Standard 2.1 project is not compatible with a .NET 7 app (instead it should).


## 🎉 A Solution

The solution I proposed was something like this:

> would it be possible for MemoryPack, when running on .NET 7, to be able to work with code generated by the source generator in both a .NET Standard 2.1 AND .NET 7 versions? Meaning that to get the full blown perf you must have all the formatters generated on .NET 7, ok, but it would still be possible for it to work with .NET Standard 2.1 formatters, just in a less performant way?

Later on, I put down more details in [this comment](https://github.com/Cysharp/MemoryPack/issues/96#issuecomment-1363435453):

> The generator can then generate the needed concrete formatter classes (like MyTypeFormatter for the type MyType) by always implementing the first interface (which would make it usable by any NET compatible with NS 2.1), and the second interface inside an #if NET7_0_OR_GREATER block, with the even more optimized version targeting NET 7.

And so on, you can read the full details there.

Now, probably because I haven't been able to explain myself clearly, MemoryPack's author responded by saying that my solution was not doable.

Also, since I had never played with source generators (but only read something here and there), maybe I was missing something or maybe I just explained myself badly 🤷‍♂️.

So anyway I created this to actually try my approach and showcase what I meant.


## ⚠ Just a POC!

Again, this is just a Proof Of Concept for the approach.

This does NOT represent real code, is NOT a serializer, is super SIMPLE and INCOMPLETE, and does NOT do anything useful.

To better understand: there's just a `Serialize()` method (no `Deserialize()`), and that method just returns a string like `"running simple code"` or something like that.

We are only interested in understanding if it is possible to have the approach I proposed, so it's not a full working project.


## 📁 Solution Structure

There are 2 core projects:

- `FooPack.Core`: contains the core interfaces and classes, like `IFooPackFormatter` (standard serialization methods) and `IFooPackFormatterNet7` (derives from `IFooSerializer` and adds optimized .NET 7 methods), on top of the global `FooPackSerializer` static class that resembles `MemoryPackSerializer`, so that `MemoryPackSerializer.Serialize(obj)` -> `FooPackSerializer.Serialize(obj)`
- `FooPack`: contains the source generator

There are 3 library projects:
- `MyLibNetStandard21`: is an intermediate lib targeting .NET Standard 2.1. It contains only 1 class which has the `[FooPackable]` attribute, so the generator will run only for .NET Standard 2.1
- `MyLibNet7`: is an intermediate lib targeting .NET 7. It contains only 1 class which has the `[FooPackable]` attribute, so the generator will run only for .NET 7
- `MyLibMultiTarget`: is an intermediate lib targeting both .NET Standard 2.1 and .NET 7. It contains only 1 class which has the `[FooPackable]` attribute, so here the generator will run for both .NET Standard 2.1 and for .NET 7 (generating 2 different dll files)

Then there are 2 console apps to test the results:
- `TestAppNet6`: is a console app targeting .NET 6 (so, compatible only with .NET Standard 2.1). It contains 1 class which has the `[FooPackable]` attribute, so here the generator will run for .NET 6. The console app tries to "serialize" the local class, the class in the `MyLibNetStandard21` project and the one in the `MyLibMultiTarget` project
- `TestAppNet7`: is a console app targeting .NET 7 (so, compatible with .NET Standard 2.1 AND with .NET 7). It contains 1 class which has the `[FooPackable]` attribute, so here the generator will run for .NET 7 only. The console app tries to "serialize" the local class, the class in the `MyLibNetStandard21` project, the one in the `MyLibNet7` project and the one in the `MyLibMultiTarget` project

Follow for the results.


## 🏆 Results

It works!

It seems to be possible to generate code that works everywhere, and is adaptively optimized when possible (eg: when the .NET runtime allows it).

If we run the `TestConsoleNet6` (targeting .NET 6, which is compatible with .NET Standard 2.1) this is the result:

![image](https://user-images.githubusercontent.com/1010086/210086713-d848bb3f-b137-4f72-95a0-cde2141d27e9.png)

We can see that it's using the "normal .NET Standard code", for both the local class (`MyClassNet6`), the class in the .NET Standard 2.1 lib (`MyClassInExtLibNetStandard21`) and for the one in the lib with multi-targeting (`MyClassInExtLibMultiTarget`).

But if we run the `TestConsoleNet7` (targeting specifically .NET 7) this is the result:

![image](https://user-images.githubusercontent.com/1010086/210086922-396fb265-3135-45cb-b888-54da319abf06.png)

We can see that it's using the "optimized .NET 7 code" everywhere automatically, for every project that target either .NET 7 directly, or with multi-targeting (.NET Standard 2.1 + .NET 7).

The only exception is for the project where the generator run targeting only .NET Standard 2.1 (`MyClassInExtLibNetStandard21`): but contrary to what currently happens in MemroyPack, it has been able to call the "normal" code without crashing.
